\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  NOP  (0x00)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore nop()\bigskip\\ 
Summary &  This function has exceptionally well performance at doing nothing \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  LD  (0x01)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore load(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Loads a fixed value into a specific register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CPY  (0x02)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore copy(unsigned char destaddr, unsigned char srcaddr)\bigskip\\ 
Summary &  Copies te value from a register to another register. The value in the source register is retained. \bigskip\\ 
Parameters & 
\nextitem \textbf{destaddr:}  The destaddr parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{srcaddr:}  The srcaddr parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  ST  (0x03)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore store(unsigned char destaddr, unsigned char srcaddr)\bigskip\\ 
Summary &  Store the value of a register to RAM. \bigskip\\ 
Parameters & 
\nextitem \textbf{destaddr:}  The destaddr parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{srcaddr:}  The srcaddr parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  STI  (0x04)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore storeImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Store a fixed value to RAM. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  LDR  (0x05)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore loadRam(unsigned char destaddr, unsigned char srcaddr)\bigskip\\ 
Summary &  Load a value from RAM into a register. \bigskip\\ 
Parameters & 
\nextitem \textbf{destaddr:}  The destaddr parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{srcaddr:}  The srcaddr parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CMP  (0x06)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore compare(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Compare two values of registers. Two results are possible: 0 means not equal, not 0 means equal. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  GT  (0x07)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore greaterThan(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Check if the first register's value is greater than the second register's value. Two results are possible: 0 means register 2's value is bigger, not 0 means register 1's value is bigger. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  GTI  (0x08)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore greaterThanImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Check if a register value is greater than a fixed value Two results are possible: 0 means the fixed value value is bigger, not 0 means the register's value is bigger. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  LT  (0x09)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore lessThan(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Check if the first register's value is smaller than the second register's value. Two results are possible: 0 means register 2's value is smaller, not 0 means register 1's value is smaller. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  LTI  (0x0A)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore lessThanImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Check if a register value is smaller than a fixed value. Two results are possible: 0 means the fixed value is smaller, not 0 means the register's value is smaller. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SWAP  (0x0B)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore swap(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Swap the values of two registers. Each register gets the value of the other register in one instruction. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SWAPR  (0x0C)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore swapRam(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Swap the values of two RAM addresses. Each RAM address gets the value of the other RAM address in one instruction. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  ADD  (0x0D)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore add(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Add the values of two registers. The result is stored in the first register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  ADDI  (0x0E)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore addImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Add a fixed value to the value of a register. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SUB  (0x0F)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore subtract(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Subtract the values of two registers. The result is stored in the first register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SUBI  (0x10)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore subtractImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Subtract a fixed value from the value of a register. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  MUL  (0x11)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore multiply(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Multiply the values of two registers. The result is stored in the first register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  MULI  (0x12)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore multiplyImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Multiply a fixed value with the value of a register. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DIV  (0x13)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore divide(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Divide the value of the first register by the value of the second register. The result is stored in the first register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DIVI  (0x14)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore divideImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Divide the value of a register by a fixed value. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  INC  (0x15)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore increment(unsigned char address)\bigskip\\ 
Summary &  Increment the value of a register by one. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DEC  (0x16)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore decrement(unsigned char address)\bigskip\\ 
Summary &  Decrement the value of a register by one. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  POW  (0x17)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore power(unsigned char destaddr, unsigned char pwraddr)\bigskip\\ 
Summary &  Calculate the power of the value of a register. The power is the value of a register with the address in the second argument. The result is stored in the first register. \bigskip\\ 
Parameters & 
\nextitem \textbf{destaddr:}  The destaddr parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{pwraddr:}  The pwraddr parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  POWI  (0x18)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore pwrvalImmediate(unsigned char destaddr, unsigned char pwrval)\bigskip\\ 
Summary &  Calculate the power of the value of a register. The power is a fixed value given as the second argument. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{destaddr:}  The destaddr parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{pwrval:}  The pwrval parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SQRT  (0x19)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore squareRoot(unsigned char address)\bigskip\\ 
Summary &  Calculate the square root of the value of a register. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  LOG2  (0x1A)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore log2(unsigned char address)\bigskip\\ 
Summary &  Calculate the log (base 2) of the value of a register. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  LOG10  (0x1B)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore log10(unsigned char address)\bigskip\\ 
Summary &  Calculate the log (base 10) of the value of a register. The result is stored in the register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  RND  (0x1C)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore rand(unsigned char rangemin, unsigned char rangemax)\bigskip\\ 
Summary &  Generate a random value in a given range. The value is an unsigned char. The range is defined by the first and the second argument as addresses of registers. \bigskip\\ 
Parameters & 
\nextitem \textbf{rangemin:}  The rangemin parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{rangemax:}  The rangemax parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  RNDI  (0x1D)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore randImmediate(unsigned char rangemin, unsigned char rangemax)\bigskip\\ 
Summary &  Generate a random value in a given range. The value is an unsigned char. The range is defined by the first and the second argument as fixed values. \bigskip\\ 
Parameters & 
\nextitem \textbf{rangemin:}  The rangemin parameter requires an unsigned short containing an 8 bit value. 
\nextitem \textbf{rangemax:}  The rangemax parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  AND  (0x1E)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore bitwiseAnd(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Performs a bitwise AND on the values of two registers. The result is stored in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  ANDI  (0x1F)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore bitwiseAndImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Performs a bitwise AND on the value of a register and a fixed value. The result is stored in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  OR  (0x20)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore bitwiseOr(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Performs a bitwise OR on the values of two registers. The result is stored in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  ORI  (0x21)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore bitwiseOrImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Performs a bitwise OR on the value of a register and a fixed value. The result is stored in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  XOR  (0x22)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore bitwiseXor(unsigned char firstaddress, unsigned char secondaddress)\bigskip\\ 
Summary &  Performs a bitwise XOR on the values of two registers. The result is stored in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstaddress:}  The firstaddress parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{secondaddress:}  The secondaddress parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  XORI  (0x23)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore bitwiseXorImmediate(unsigned char address, unsigned char value)\bigskip\\ 
Summary &  Performs a bitwise XOR on the value of a register and a fixed value. The result is stored in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  NOT  (0x24)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore bitwiseNot(unsigned char address)\bigskip\\ 
Summary &  Performs a bitwise NOT of the value of a registers. The result is stored in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SBIT  (0x25)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore setBit(unsigned char address, unsigned char position)\bigskip\\ 
Summary &  Sets a bit in a register's value, sepcified by the second argument. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{position:}  The position parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CBIT  (0x26)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore clearBit(unsigned char address, unsigned char position)\bigskip\\ 
Summary &  Clears a bit in a register's value, sepcified by the second argument. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\nextitem \textbf{position:}  The position parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  JMP  (0x27)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore jump(unsigned short address)\bigskip\\ 
Summary &  Jumps inconditionally to the instruction address specified in the first argument. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  JMPR  (0x28)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore jumpRelative(unsigned short address)\bigskip\\ 
Summary &  Jumps inconditionally by incrementing the program counter with the value of the first argument. If the the program counter overflows, execution of the program is aborted. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  JMPZ  (0x29)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore jumpIfZero(unsigned short address)\bigskip\\ 
Summary &  Jumps if the HL register's value equals zero to the instruction address specified in the first argument. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  JMPRZ  (0x2A)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore jumpRelativeIfZero(unsigned short address)\bigskip\\ 
Summary &  Jumps if the HL register's value equals zero by incrementing the program counter with the value of the first argument. If the the program counter overflows, execution of the program is aborted. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  JMPNZ  (0x2B)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore jumpIfNotZero(unsigned short address)\bigskip\\ 
Summary &  Jumps if the HL register's value does not equal zero to the instruction address specified in the first argument. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  JMPRNZ  (0x2C)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore jumpRelativeIfNotZero(unsigned short address)\bigskip\\ 
Summary &  Jumps if the HL register's value does not equal zero by incrementing the program counter with the value of the first argument. If the the program counter overflows, execution of the program is aborted. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CALL  (0x2D)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore call(unsigned short address)\bigskip\\ 
Summary &  Executes a subroutine at the address specified in the first argument. Starts by pushing the program counter to the stack. At the end of a subroutine, RET should be called to pop the program counter from the stack and return to the last execution point. If the the program counter overflows, execution of the program is aborted. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CALLNZ  (0x42)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore callIfNotZero(unsigned short address)\bigskip\\ 
Summary &  Performs a call if and only if the HL register does not contain zero. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CALLZ  (0x43)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore callIfZero(unsigned short address)\bigskip\\ 
Summary &  Performs a call if and only if the HL register contains zero. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  RET  (0x2E)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore ret()\bigskip\\ 
Summary &  Pops the program counter from the stack and returns to execution after a subroutine was called. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  PUSH  (0x2F)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore push(unsigned char address)\bigskip\\ 
Summary &  Pushes a register's value to the stack. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing an 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  PUSHI  (0x30)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore pushImmediate(unsigned char value)\bigskip\\ 
Summary &  Pushes a fixed value to the stack. \bigskip\\ 
Parameters & 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  POP  (0x31)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore pop(unsigned char address)\bigskip\\ 
Summary &  Pops a value from the stack to a register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  BRD  (0x32)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore buttonRead(unsigned char id)\bigskip\\ 
Summary &  Reads a controller and places the input in the HL register. The id as the first argument is either 0 or 1, depending on the controller that is to be read. \bigskip\\ 
Parameters & 
\nextitem \textbf{id:}  The id parameter requires an unsigned short containing a 8 bit id. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  BRDS  (0x33)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore buttonReadSingle(unsigned char id, unsigned char btn)\bigskip\\ 
Summary &  Reads a controller and places the input of a specific button in the HL register. If the button is pressed, 1 is placed in HL, else 0. The id as the first argument is either 0 or 1, depending on the controller that is to be read. The button as the second argument is the button that is to be read, for more info, see the controller chapter. \bigskip\\ 
Parameters & 
\nextitem \textbf{id:}  The id parameter requires an unsigned short containing a 8 bit id. 
\nextitem \textbf{btn:}  The btn parameter requires an unsigned short containing a 8 bit button id. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  WAITF  (0x34)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore waitFor(unsigned char id, unsigned char btn)\bigskip\\ 
Summary &  Pauses execution of a program until a specific button or buttoncombination is pressed. As long as the buttoncombination does not equal the given one, the program halts. \bigskip\\ 
Parameters & 
\nextitem \textbf{id:}  The id parameter requires an unsigned short containing a 8 bit id. 
\nextitem \textbf{btn:}  The btn parameter requires an unsigned short containing a 8 bit button id. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SCRH  (0x35)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore screenHeight()\bigskip\\ 
Summary &  Places the screenheight in the HL register. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SCRW  (0x36)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore screenWidth()\bigskip\\ 
Summary &  Places the screenwidth in the HL register. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SSPR  (0x37)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore setSprite(unsigned char index, unsigned char indexonscreen)\bigskip\\ 
Summary &  Places a sprite from code to VRAM. The first argument is the index in the sprite array in code. The second argument is the index in the on-screen sprite array. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  The index parameter requires an unsigned short containing a 8 bit index. 
\nextitem \textbf{indexonscreen:}  The indexonscreen parameter requires an unsigned short containing a 8 bit index. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  USPR  (0x38)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore updateSprite(unsigned char indexonscreen, unsigned char x, unsigned char y)\bigskip\\ 
Summary &  Updates the position of the sprite on the screen. Positioning the sprite out of the bounds of the screen makes the sprite invisible. The second and third argument contain respectively the register with the x position and the y position. \bigskip\\ 
Parameters & 
\nextitem \textbf{indexonscreen:}  The indexonscreen parameter requires an unsigned short containing a 8 bit index. 
\nextitem \textbf{x:}  The x parameter requires an unsigned short containing a 8 bit address. 
\nextitem \textbf{y:}  The y parameter requires an unsigned short containing a 8 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  USPRI  (0x4A)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore updateSpriteImmediate(unsigned char indexonscreen, unsigned char x, unsigned char y)\bigskip\\ 
Summary &  Updates the position of the sprite on the screen. Positioning the sprite out of the bounds of the screen makes the sprite invisible. The second and third argument contain respectively the x position and the y position. \bigskip\\ 
Parameters & 
\nextitem \textbf{indexonscreen:}  The indexonscreen parameter requires an unsigned short containing a 8 bit index. 
\nextitem \textbf{x:}  The x parameter requires an unsigned short containing a 8 bit value. 
\nextitem \textbf{y:}  The y parameter requires an unsigned short containing a 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CSPR  (0x39)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore clearSprite(unsigned char indexonscreen)\bigskip\\ 
Summary &  Removes a sprite from the onscreen sprite index. \bigskip\\ 
Parameters & 
\nextitem \textbf{indexonscreen:}  The indexonscreen parameter requires an unsigned short containing a 8 bit index. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SPRX  (0x3A)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore checkSpriteX(unsigned char firstindexonscreen, unsigned char secondindexonscreen)\bigskip\\ 
Summary &  Calculates the horizontal distance between two sprites. The distance (in pixels) is placed in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstindexonscreen:}  The firstindexonscreen parameter requires an unsigned short containing a 8 bit index. 
\nextitem \textbf{secondindexonscreen:}  The secondindexonscreen parameter requires an unsigned short containing a 8 bit index. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SPRY  (0x3B)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore checkSpriteY(unsigned char firstindexonscreen, unsigned char secondindexonscreen)\bigskip\\ 
Summary &  Calculates the vertical distance between two sprites. The distance (in pixels) is placed in the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{firstindexonscreen:}  The firstindexonscreen parameter requires an unsigned short containing a 8 bit index. 
\nextitem \textbf{secondindexonscreen:}  The secondindexonscreen parameter requires an unsigned short containing a 8 bit index. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SMAP  (0x3C)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore setMap(unsigned char index)\bigskip\\ 
Summary &  Draws a map on the screen. The first argument is the index of the map in the map memory. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  The index parameter requires an unsigned short containing a 8 bit index. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  SSTR  (0x3D)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore setString(unsigned char index, unsigned char x, unsigned char y)\bigskip\\ 
Summary &  Draws a string on the screen at a specified position. The first argument is the index of the string in the string memory. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  The index parameter requires an unsigned short containing a 8 bit index. 
\nextitem \textbf{x:}  The x parameter requires an unsigned short containing a 8 bit value. 
\nextitem \textbf{y:}  The y parameter requires an unsigned short containing a 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DLY  (0x3E)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore delay(unsigned char index)\bigskip\\ 
Summary &  Waits for an amount of milliseconds equal to the value of the register given in the first argument. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  The index parameter requires an unsigned short containing a 8 bit index. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DLYI  (0x3F)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore delayImmediate(unsigned char value)\bigskip\\ 
Summary &  Waits for an amount of milliseconds equal to the fixed value given in the first argument. \bigskip\\ 
Parameters & 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing a 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  CTMR  (0x40)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore clearTimer()\bigskip\\ 
Summary &  Clears the timer by resetting its value to zero. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  RTMR  (0x41)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore readTimer()\bigskip\\ 
Summary &  Places the value of the timer in the HL register. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DON  (0x44)\bigskip\\ 
\hline 
 \hline 
Function header & inline void allOn()\bigskip\\ 
Summary &  Sets all pixels on the screen to the on-state. The actual framebuffer is not affected. To get back to drawing the buffer, call normalMode(). No redraw is needed to change the state. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DOFF  (0x45)\bigskip\\ 
\hline 
 \hline 
Function header & inline void allOff()\bigskip\\ 
Summary &  Sets all pixels on the screen to the off-state. The actual framebuffer is not affected. To get back to drawing the buffer, call normalMode(). No redraw is needed to change the state. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DINV  (0x46)\bigskip\\ 
\hline 
 \hline 
Function header & inline void invertedMode()\bigskip\\ 
Summary &  Sets the screen to drawing the framebuffer inverted. The actual framebuffer is not affected, nor the operation of its states. A cleared pixel will be lit, and a lit pixel will be cleared on screen. No redraw is needed to change the state. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DNRM  (0x47)\bigskip\\ 
\hline 
 \hline 
Function header & inline void normalMode()\bigskip\\ 
Summary &  Sets the screen to drawing the framebuffer. No redraw is needed to change the state. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DRDRW  (0x48)\bigskip\\ 
\hline 
 \hline 
Function header & inline void redraw()\bigskip\\ 
Summary &  Redraws the framebuffer to the screen. If allOn or allOff has been called right before a redraw, it is needed to call normalMode to draw the framebuffer. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  DCLR  (0x49)\bigskip\\ 
\hline 
 \hline 
Function header & inline void clearAll()\bigskip\\ 
Summary &  Clears the entire framebuffer by resetting its pixelvalues to zero. Will only be seen after a redraw. After a clearAll, the framebuffer can be written to immediately to update the screen. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  RDAT  (0x4B)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore readDataMemory(address)\bigskip\\ 
Summary &  Reads a byte from the cartridge data memory to the HL register. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  WDAT  (0x4C)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore writeToDataMemory(unsigned short address, unsigned char value)\bigskip\\ 
Summary &  Writes a register's value to the cartridge data memory. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit index. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Mnemonic (opcode) &  WDATI  (0x4D)\bigskip\\ 
\hline 
 \hline 
Function header & inline void ip\textunderscore writeToDataMemoryImmediate(unsigned short address, unsigned char value)\bigskip\\ 
Summary &  Writes a fixed value to the cartridge data memory. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. 
\nextitem \textbf{value:}  The value parameter requires an unsigned short containing an 8 bit value. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void ip\textunderscore initInterpreter();\bigskip\\ 
\hline 
\hline Summary &  Inits the interpreter by resetting all its properties. This should be called before each ip\textunderscore startInterpreter(). \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void ip\textunderscore startInterpreter();\bigskip\\ 
\hline 
\hline Summary &  Starts the actual interpreter. Before each ip\textunderscore startInterpreter call, ip\textunderscore initInterpreter should be called unless the state of the interpreter is to be saved. To be able to execute code, a RAM module should be attached to the controller containing the code, sprites, maps and strings, carefully mapped to the memory. define DEBUGASSERT at the top to enable assert functions to be used, turned off by default. These asserts can check if a method actually does what it is supposed to do, and can help debugging of written code. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore initSlaveSelect();\bigskip\\ 
\hline 
\hline Summary & \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & unsigned char io\textunderscore readProgramMemory(unsigned short address);\bigskip\\ 
\hline 
\hline Summary &  This function reads 1 byte of data from the external program RAM chip at a given address. The program RAM contains the program code that is executed by the interpreter. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. The program address range is from 0x00000 to 0x0FFFF. 
\bigskip \\ 
Returns &  This method returns a unsigned char containing the data that was stored at the given address. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & unsigned char io\textunderscore readDataMemory(unsigned short address);\bigskip\\ 
\hline 
\hline Summary &  This function reads 1 byte of data from the external data RAM chip at a given address. The data RAM contains the sprites, maps, strings, settings and savebanks. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. The data address range is from 0xF0000 to 0xFFFFF. 
\bigskip \\ 
Returns &  This method returns a unsigned char containing the data that was stored at the given address. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore writeToDataMemory(unsigned short address, unsigned char data);\bigskip\\ 
\hline 
\hline Summary &  This function writes 1 byte of data to the external data RAM at a given address. \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an unsigned short containing a 16 bit address. The data address range is from 0xF0000 to 0xFFFFF. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & unsigned char io\textunderscore readController(unsigned char controllerNumber);\bigskip\\ 
\hline 
\hline Summary &  This function reads the game controller buttons state for a given controller number. \bigskip\\ 
Parameters & 
\nextitem \textbf{ControllerNumber:}  This parameter contains the controller number: Controller1 = 0x00 Controller2 = 0xff 
\bigskip \\ 
Returns &  The method returns a unsigned char containing the controller button state. The meaning of each bit: BIT 0: A BIT 1: B BIT 2: SELECT BIT 3: START BIT 4: DPAD UP BIT 5: DPAD DOWN BIT 6: DPAD LEFT BIT 7: DPAD RIGHT \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore initIO();\bigskip\\ 
\hline 
\hline Summary &  This function sets up the IOcontrol interface. It performs the following actions: - RAM interface setup - SoftSPI interface setup and slave select initialisation - Loads the sprites into the video memory - Loads the strings into the video memory - Loads the maps into the video memory \bigskip\\ 
Note &  This function has a long execution time. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore allOn();\bigskip\\ 
\hline 
\hline Summary &  This function lights up all the pixels of the LCD screen without overwriting the video memory. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore allOff();\bigskip\\ 
\hline 
\hline Summary &  This function disables all the pixels of the LCD screen without overwriting the video memory. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore invert();\bigskip\\ 
\hline 
\hline Summary &  This function inverts all the pixels of the LCD screen overwriting the video memory. This means that a black pixel turns white and a white pixel turns into black. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore setCursor(unsigned char x , unsigned char y);\bigskip\\ 
\hline 
\hline Summary &  This function sets the coordinates of the LCD display in the videobuffer. TOTO: EXPLAIN The coordinate (0,0) is located top left. \bigskip\\ 
Parameters & 
\nextitem \textbf{x:}  This parameter of type unsigned char contains the x-coordinate of the cursor. 
\nextitem \textbf{y:}  This parameter of type unsigned char contains the y-coordinate of the cursor. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore updateSprite(unsigned char indexVram,unsigned char x, unsigned char y);\bigskip\\ 
\hline 
\hline Summary &  This function updates the position of a sprite in the video memory. \bigskip\\ 
Parameters & 
\nextitem \textbf{indexVram:}  This parameter of type unsigned char container the index of the sprite in the video RAM. 
\nextitem \textbf{x:}  This parameter of type unsigned char contains the x-coordinate of the cursor. 
\nextitem \textbf{y:}  This parameter of type unsigned char contains the y-coordinate of the cursor. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore setSprite(unsigned char index, unsigned char indexVram);\bigskip\\ 
\hline 
\hline Summary &  This function initialize a sprite in the video memory at a given position. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  This parameter of type unsigned char contains the index of the sprite in ROM memory. 
\nextitem \textbf{indexVram:}  This parameter of type unsigned char container the index of the sprite in the video RAM. 
\nextitem \textbf{x:}  This parameter of type unsigned char contains the x-coordinate of the cursor. 
\nextitem \textbf{y:}  This parameter of type unsigned char contains the y-coordinate of the cursor. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore clearSprite(unsigned char index);\bigskip\\ 
\hline 
\hline Summary &  This function clears a sprite given by the index parameter in the video memory. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  This parameter of type unsigned char contains the index of the sprite in ROM memory. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore drawString(unsigned char index, unsigned char x, unsigned char y);\bigskip\\ 
\hline 
\hline Summary &  This function draws a string given by the index parameter on the screen at a given position. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  This parameter of type unsigned char contains the index of the string in ROM memory. 
\nextitem \textbf{x:}  This parameter of type unsigned char contains the x-coordinate of the cursor. 
\nextitem \textbf{y:}  This parameter of type unsigned char contains the y-coordinate of the cursor. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore drawMap(unsigned char index);\bigskip\\ 
\hline 
\hline Summary &  This function draws a map with a given index on the LCD screen. \bigskip\\ 
Parameters & 
\nextitem \textbf{index:}  This parameter of type unsigned char contains the index of the map in ROM memory. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore clearAll();\bigskip\\ 
\hline 
\hline Summary &  This function clears al the elements on the LCD screen. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore clearStrings();\bigskip\\ 
\hline 
\hline Summary &  This function clears the string buffer. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore clearGraphics();\bigskip\\ 
\hline 
\hline Summary &  This function clears the display buffer. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore redraw();\bigskip\\ 
\hline 
\hline Summary &  This function redraws the displaybuffer to the LCD screen. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void io\textunderscore normalMode();\bigskip\\ 
\hline 
\hline Summary &  This function sets the LCD screen back to normal mode. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void rd\textunderscore initRAM();\bigskip\\ 
\hline 
\hline Summary & \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void rd\textunderscore setBank(unsigned char bank);\bigskip\\ 
\hline 
\hline Summary &  This function selects a memorybank. \bigskip\\ 
Parameters & 
\nextitem \textbf{bank:}  The bank parameter contains the selected bank: PROGMEM = 0, DATAMEM = 1 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & unsigned char rd\textunderscore getBank();\bigskip\\ 
\hline 
\hline Summary &  Function to get the selected bank \bigskip\\ 
Returns &  The method returns a unsigned char containing the selected bank \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void rd\textunderscore writeToRAM(unsigned short address, unsigned char value);\bigskip\\ 
\hline 
\hline Summary &  Function to write data (1 byte) to the external RAM in a given address \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an 16 bit address (unsigned short) 
\nextitem \textbf{value:}  Parameter value is helds the value that needs to be stored in the ROM 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & unsigned char rd\textunderscore readFromRAM(unsigned short address);\bigskip\\ 
\hline 
\hline Summary &  Function the read data (1 byte) from a given address \bigskip\\ 
Parameters & 
\nextitem \textbf{address:}  The address parameter requires an 16 bit address (unsigned short). 
\bigskip \\ 
Returns &  The method returns a unsigned char containing the data in the address \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void ss\textunderscore initSPI();\bigskip\\ 
\hline 
\hline Summary &  Initialisation of the software SPI pins. Sets all the output pins low. Mind the tris register, this has to be set manually! The standard in this case is trisa = 0b00000100; \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & void ss\textunderscore sendByte(unsigned char data);\bigskip\\ 
\hline 
\hline Summary &  Sends a byte over SPI to the selected slave. \bigskip\\ 
Parameters & 
\nextitem \textbf{data:}  The data argument is an unsigned char, the byte we want to send. 
\bigskip \\ 
\hline 
 \end{tabularx} 
 \end{table} 
\begin{table}[H]
\begin {tabularx} {\textwidth} {l|X} Function header & unsigned char ss\textunderscore readByte();\bigskip\\ 
\hline 
\hline Summary &  Reads a byte over SPI from the selected slave. \bigskip\\ 
Returns &  The method returns an unsigned char, the data received over SPI. \bigskip\\ 
\hline 
 \end{tabularx} 
 \end{table} 
